<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="http://s3-ap-northeast-1.amazonaws.com/hello-devops/favicon.png" type="image/png">
  <link rel="icon" href="http://s3-ap-northeast-1.amazonaws.com/hello-devops/favicon.png" type="image/png">

  <meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@yihungjen">

<meta name="twitter:title" content="Beyond Virtual Machine, into Docker | Hello DevOps">


<meta name="twitter:description" content="With three use cases: Running Ruby app in a continer, building native program with a container, and a portable workspcae that could be deployed on any linux machine, I demonstrate why Docker will r...">


<meta name="twitter:image:src" content="http://s3-ap-northeast-1.amazonaws.com/hello-devops/logo.png">



  <title>Beyond Virtual Machine, into Docker</title>
  <meta name="description" content="Consumers today have two options (three if you bother the hassel) whenpurchasing device for work: either you have one with OS X installed, orWindows installe...">

  <link rel="stylesheet" href="/hello-devops/css/main.css">
  <link rel="canonical" href="/hello-devops/blog/docker/2016/04/23/beyond-virtual-machine/">
  <link rel="alternate" type="application/rss+xml" title="Hello DevOps" href="/hello-devops/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/hello-devops/">Hello DevOps</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/hello-devops/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Beyond Virtual Machine, into Docker</h1>
    <p class="post-meta"><time datetime="2016-04-23T10:00:00+00:00" itemprop="datePublished">Apr 23, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Consumers today have two options (three if you bother the hassel) when
purchasing device for work: either you have one with <strong>OS X</strong> installed, or
<strong>Windows</strong> installed (and for hard core fans, your choice of <strong>unix</strong>).  This
creates a problem for application developers because the environment you work
and test in is different from your deployment target, usually a unix/linux box.</p>

<p>For those working with windows server, don’t even bother with your complaints.
<a href="https://www.linux.com/news/bash-windows-what-does-it-mean">Look at where Microsoft is heading</a>.</p>

<p>For any developers worth their salt, you would have already learned how to work
with Virtual Machines.  With the advent of <a href="https://www.vagrantup.com/">Vagrant</a>,
provisioning on localhost had been made <em>hassel free</em>.  If you have never heard
of such wonderful creation, go look at
<a href="/hello-devops/blog/vagrant/2016/03/12/how-i-build-this-blog-site/">How I build this blog site</a>
for a tour.</p>

<h2 id="the-problem">The Problem</h2>
<p>Still with Virtual Machine the biggest pain point is the amount of resource
and time spent when dealing with many boxes at once.  This problem occurs often
when working as a DevOps where mapping test environment to match
staging/production environment is necessary.  You could purchase VMWare
solutions or build your own OpenStack infrastructure, but really is this
necessary?</p>

<h2 id="the-answer">The Answer</h2>
<p>The answer is <a href="https://www.docker.com/">Docker</a>.</p>

<!--more-->

<p>Instead of explaining to you the technology of
<a href="https://www.docker.com/">Docker</a>, I opt to demonstrate use cases where Docker
eliminates the need for Virtual Machine, and make your work life better.</p>

<p>But first, lets setup an environment to run Docker.  Two choices here:</p>

<ul>
  <li>Install using <a href="https://www.docker.com/products/docker-toolbox">Docker Toolbox</a></li>
  <li><a href="#for-the-brave-tinkerer">Build a Virtual Machine with Docker installed.</a></li>
</ul>

<h2 id="nomenclature">Nomenclature:</h2>
<ul>
  <li>A <strong>Container</strong> is a linux kernel feature that provides software level
isolation.</li>
  <li>Container can be created, started, stoped, and removed.</li>
  <li>An <strong>Image</strong>  is the execution context.  A Container is created with an
Image.</li>
  <li><strong>Dockerfile</strong> is the recipe for building a Image.</li>
  <li>Each <strong>RUN</strong>, <strong>ADD</strong>, <strong>COPY</strong>, etc adds a <strong>Layer</strong> to the Image.</li>
  <li><strong>ENTRYPOINT</strong> is the command that runs when the Container is started.</li>
  <li><strong>CMD</strong> has two meaning:
    <ul>
      <li>When an ENTRYPOINT is specified, CMD will be tacked on as arguments to
ENTRYPOINT.</li>
      <li>If we specified CMD without ENTRYPOINT, that is the command at container
start.</li>
      <li>CMD can be overrided at the command line.</li>
    </ul>
  </li>
  <li>You <strong>store and ship</strong> the image.</li>
</ul>

<h2 id="running-program-in-an-isolated-environment">Running program in an isolated environment</h2>
<p>Node.js, Ruby, and Python apps depend on a interpreter to work.  If you are
running an application written in those language ONLY for the feature it
provides, not to develop with it, there is very little reason to install the
interpreter on the system.</p>

<p>For example, I am not a Ruby developer, but I want to use
<a href="https://jekyllrb.com/">jekyll</a> for blog generation; instead of installing
Ruby which I will rarely use, I packaged jekyll as a Docker Image.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/fc8739efcd89c4557005cde416731506.js"> </script>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Download Dockerfile for jekyll</span>
curl -sL -o Dockerfile http://bit.ly/Dockerfile-jekyll
<span class="c"># Build docker image</span>
docker build -t jekyll .
<span class="c"># Download the helper script</span>
curl -sL -O http://bit.ly/jekyll-cli
<span class="c"># Make it executable</span>
chmod +x jekyll-cli
<span class="c"># Create a new blog src if you don't have one already</span>
./jekyll-cli new your-blog-src
<span class="c"># Launch jekyll to serve and watch files</span>
./jekyll-cli serve -s your-blog-src -d your-blog-site -H 0.0.0.0</code></pre></figure>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin-bottom: 10px;} .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>

<div class="embed-container">
<iframe width="100%" src="https://www.youtube.com/embed/S1beABvOPCA" frameborder="0" allowfullscreen=""></iframe>
</div>

<p>Visit your site from your host machine at <code class="highlighter-rouge">localhost:8080</code></p>

<p>List the images by running <code class="highlighter-rouge">docker images</code>.</p>

<h3 id="what-had-just-happened">What had just happened?</h3>

<ul>
  <li>Docker Daemon pulled image <code class="highlighter-rouge">ruby:latest</code> from <a href="https://hub.docker.com/">Docker Hub</a>
to your disk</li>
  <li><code class="highlighter-rouge">ruby:latest</code> is the base image that provides <code class="highlighter-rouge">ruby</code> interpreter and
<code class="highlighter-rouge">build-essentials</code> for building native gems.</li>
  <li>We specified <code class="highlighter-rouge">jekyll</code> to be the <code class="highlighter-rouge">entrypoint</code> of the image, and the default
command line flag is <code class="highlighter-rouge">--help</code></li>
</ul>

<h3 id="why-is-this-better">Why is this better?</h3>

<ul>
  <li>You did not install Ruby for just one app.</li>
  <li>The Linux Distro you are using might not have Ruby 2.x available.  To get
around this you need <a href="https://rvm.io/">rvm</a> to fetch and build Ruby from
source.</li>
  <li>Suppose you wanted to try an alpha version of jekyll, you need only change the
gem version and build a sepearte Docker Image.  <strong>No rollback worries</strong>.</li>
</ul>

<h2 id="developing-in-the-target-environment">Developing in the target environment</h2>
<p>I am a <a href="https://golang.org/">Golang</a> enthusiast; Golang by itself deserves a
dedicated topic and <strong>should be picked up by any DevOps who wants to ship
compact artifacts</strong>.  But in order to build and write in Golang I need the Go
developer tool chain installed on my host machine to compile/build Go code…
right?</p>

<p><strong>No</strong>.  You could write the code in your preferred environment.  When you are
ready to build, build with Docker.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Find a place to make Gopher home</span>
<span class="nb">export </span><span class="nv">GOPATH</span><span class="o">=</span>/path/to/go
mkdir -p <span class="k">${</span><span class="nv">GOPATH</span><span class="k">}</span>/src <span class="k">${</span><span class="nv">GOPATH</span><span class="k">}</span>/pkg <span class="k">${</span><span class="nv">GOPATH</span><span class="k">}</span>/bin
<span class="nb">cd</span> <span class="k">${</span><span class="nv">GOPATH</span><span class="k">}</span>
<span class="c"># Setup script to run golang image as command</span>
cat <span class="sh">&lt;&lt;EOF &gt;/usr/local/bin/go
#!/bin/bash
docker run --rm -v ${GOPATH}:/go golang:1.6 go \$@
EOF
</span>chmod +x /usr/local/bin/go
<span class="c"># Now, lets get the official golang tutorial</span>
go get golang.org/x/tour/gotour
<span class="c"># And run the tour</span>
./bin/gotour -http 0.0.0.0:8080</code></pre></figure>

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin-bottom: 10px;} .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style>

<div class="embed-container">
<iframe width="100%" src="https://www.youtube.com/embed/ZGHlj5I1tFs" frameborder="0" allowfullscreen=""></iframe>
</div>

<h3 id="what-is-this-mad-magic">What is this mad magic</h3>
<ul>
  <li>We created a helper script to wrap the <em>docker command</em> to represent <strong>go</strong>
binary</li>
  <li>This command creates and start a one time <code class="highlighter-rouge">container</code> using <em>golang:1.6</em>
image.</li>
  <li>Bind directory <code class="highlighter-rouge">${GOPATH}</code> on your <code class="highlighter-rouge">host</code> to <code class="highlighter-rouge">/go</code> in the <code class="highlighter-rouge">container</code>.</li>
</ul>

<h3 id="no-like-v16">No like v1.6!!</h3>
<p>Fine.  Change the image version to <code class="highlighter-rouge">golang:1.5</code>.</p>

<p>Think about what had just become available: <strong>You can switch between language
versions without conflict with the one installed on your system</strong>.</p>

<p>Imagine you are an author of a quite successful open source project.  You want
to support different versions of the language runtime.  To ensure that it works
over these environments, you need to build and test them properly.  Before, you
could try to spin up VMs to deal with these disparate environments, now you
simply build and test in different containers.</p>

<h2 id="a-shippable-environment">A shippable environment</h2>
<p>You might have picked up the trend here with the introduction of <em>Ruby</em> and
<em>Golang</em> base images.  These images are built and maintained by the
<a href="https://hub.docker.com/">Docker Hub</a> team so that users could repliably
reproduce an environment with Ruby or Golang installed.  In the same vein, you
could build and ship full applications as Docker images and be confident that
these applications will not have unmet dependencies.</p>

<p>But a Docker image can be more then just an application package.  You could
ship <strong>the whole environment</strong> as an image, bells and whistles included, so that
people in your organization <strong>works with consistent tool chain</strong>.</p>

<p>Take my own <a href="https://github.com/jeffjen/workspace/blob/master/Dockerfile">Dockerfile</a>
as an example, when I move to a new host machine, I can restore my workspace by</p>

<ul>
  <li>Bootstrap the machine to run Docker</li>
  <li>Pull my workspace image and launch
    <ul>
      <li>Golang, Node.js, Python, and Ruby installed</li>
      <li>Command line utility tools installed</li>
      <li>Text editor installed and configured</li>
      <li>Shell environment installed and configured</li>
    </ul>
  </li>
</ul>

<h2 id="for-the-brave-tinkerer">For the brave tinkerer</h2>
<p>For those of you who want more control over your Docker Environment, here is a
step by step guide using <strong>Vagrant</strong>.</p>

<noscript><pre># -*- mode: ruby -*-
# vi: set ft=ruby :

$install_docker_engine = &lt;&lt;SCRIPT
# Setup docker engine
apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
apt-get update &amp;&amp; apt-get install -y \
        apt-transport-https \
        linux-image-extra-$(uname -r)

echo &quot;deb https://apt.dockerproject.org/repo ubuntu-trusty main&quot; | tee /etc/apt/sources.list.d/docker.list

# install docker engine
apt-get update &amp;&amp; apt-get install -y \
    curl \
    docker-engine \
    htop \
    jq \
    lvm2 \
    ntp
SCRIPT

$configure_docker_engine = &lt;&lt;SCRIPT
mkdir -p /etc/docker /etc/default

chmod go+rx /etc/docker /etc/default

cat &lt;&lt;\EOF &gt;/etc/docker/daemon.json 
{
  &quot;hosts&quot;: [
    &quot;unix:///var/run/docker.sock&quot;,
    &quot;0.0.0.0:2375&quot;
  ]
}
EOF

cat &lt;&lt;\EOF &gt;/etc/default/docker
# Default runtime options for Docker Daemon
# For debian and ubuntu
# - Change file under /etc/default/docker
# For CentOS and RHEL
# - Change file under /etc/sysconfig/docker
# See available configuration option on https://docs.docker.com/engine/reference/commandline/daemon/
#
DOCKER_OPTS=&quot;--config-file=/etc/docker/daemon.json&quot;
EOF

# Restart docker daemon to reflect changes
service docker restart
SCRIPT

VAGRANTFILE_API_VERSION = &quot;2&quot;

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
    config.ssh.forward_agent = true
    config.ssh.forward_x11 = true

    config.vm.box = &quot;ubuntu/trusty64&quot;
    config.vm.box_check_update = true
    config.vm.provider &quot;virtualbox&quot; do |vb|
        vb.gui = false
        vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, &quot;512&quot;]
    end

    config.vm.define &quot;docker-workspace&quot; do |m|
        m.vm.provider &quot;virtualbox&quot; do |vb|
            vb.name = &quot;docker-workspace&quot;
        end
        m.vm.provision &quot;shell&quot;, inline: $install_docker_engine
        m.vm.provision &quot;shell&quot;, inline: $configure_docker_engine
        m.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;
        m.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080
        m.vm.network &quot;forwarded_port&quot;, guest: 2375, host: 2375
        m.vm.network &quot;forwarded_port&quot;, guest: 2379, host: 2379
        m.vm.network &quot;forwarded_port&quot;, guest: 4040, host: 4040
        m.vm.network &quot;forwarded_port&quot;, guest: 9090, host: 9090
    end

end</pre></noscript>
<script src="https://gist.github.com/jeffjen/a3d4830c06b716ae26c4.js"> </script>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Move to your desired workspace</span>
mkdir -p /path/to/Docuement
<span class="c"># Download Vagrantfile</span>
curl -sL -o Vagrantfile http://bit.ly/Vagrantfile-docker
<span class="c"># Provision the box</span>
vagrant up docker-workspace</code></pre></figure>

<h3 id="how-to-configure-docker-daemon">How to configure Docker Daemon</h3>
<p>Docker Daemon by default listens on Unix Domain Socket <code class="highlighter-rouge">/var/run/docker.sock</code>.
This prevents accidental provisioning from unwanted party.</p>

<p>Since we are <em>professional</em> DevOps and we know what we are doing, let us
configure the Daemon to listen on TCP and Unix Domain Socket.</p>

<noscript><pre>{
  &quot;hosts&quot;: [
    &quot;unix:///var/run/docker.sock&quot;,
    &quot;0.0.0.0:2375&quot;
  ]
}</pre></noscript>
<script src="https://gist.github.com/jeffjen/cd96d92d0318f58e9901138d08851f85.js"> </script>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mkdir -p /etc/docker
curl -sL -o /etc/docker/daemon.json http://bit.ly/docker-daemon-cfg</code></pre></figure>

<h3 id="assume-you-are-working-with-debianubuntu">Assume you are working with debian/ubuntu</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">curl -sL -o /etc/default/docker http://bit.ly/docker-default-options</code></pre></figure>

<h3 id="assume-you-are-working-with-centosrhel">Assume you are working with CentOS/RHEL</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">curl -sL -o /etc/sysconfig/docker http://bit.ly/docker-default-options</code></pre></figure>

<p>Once the configuration files are in place, restart the Docker Daemon:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">service docker restart</code></pre></figure>

<h3 id="download-the-command-line-docker-client">Download the command line Docker client</h3>
<p>Now that the Daemon is available on port <code class="highlighter-rouge">2375</code>, we can start using docker
client from your <strong>host machine</strong>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Download and install docker client</span>
curl -sL -O https://get.docker.com/builds/<span class="sb">`</span>uname -s<span class="sb">`</span>/<span class="sb">`</span>uname -m<span class="sb">`</span>/docker-1.11.0.tgz
tar xvf docker-1.11.0.tgz
cp docker/docker /usr/local/bin/docker
<span class="c"># Test connection to Docker Daemon</span>
docker -H localhost:2375 version</code></pre></figure>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Hello DevOps</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Hello DevOps</li>
          <li><a href="mailto:yihungjen@gmail.com">yihungjen@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jeffjen"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jeffjen</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/yihungjen"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">yihungjen</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A DevOps, Engineer, Half-and-half Social Retard foraging into the wild wonderlands of post Cloud Computing rukus and miscellaneous things happening to me in life.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
